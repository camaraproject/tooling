name: derive-release-state
description: |
  Derives the current release state and release tag from repository artifacts.
  Examines tags, branches, releases, and release-plan.yaml to determine
  whether a release is planned, has an active snapshot, has a draft ready,
  is published, or is not planned.

  The release_tag is derived from the authoritative source:
  - PLANNED/NOT_PLANNED: from release-plan.yaml on main branch
  - SNAPSHOT_ACTIVE/DRAFT_READY: from release-metadata.yaml on snapshot branch
  - PUBLISHED: from the git tag

inputs:
  release_tag:
    description: "Release tag to check - DEPRECATED: leave empty to auto-derive from repository artifacts"
    required: false
    default: ""

outputs:
  release_tag:
    description: "Release tag from authoritative source (release-plan.yaml or release-metadata.yaml)"
    value: ${{ steps.derive.outputs.release_tag }}
  state:
    description: "Current release state (planned|snapshot-active|draft-ready|published|not_planned)"
    value: ${{ steps.derive.outputs.state }}
  snapshot_id:
    description: 'Current snapshot ID if active (e.g., "r4.1-abc1234")'
    value: ${{ steps.derive.outputs.snapshot_id }}
  snapshot_branch:
    description: "Current snapshot branch name if active"
    value: ${{ steps.derive.outputs.snapshot_branch }}
  release_review_branch:
    description: "Current release-review branch name if active"
    value: ${{ steps.derive.outputs.release_review_branch }}
  release_pr_number:
    description: "Release PR number if exists"
    value: ${{ steps.derive.outputs.release_pr_number }}
  src_commit_sha:
    description: "Source commit SHA the snapshot was created from"
    value: ${{ steps.derive.outputs.src_commit_sha }}
  release_type:
    description: "Release type from release-metadata.yaml (e.g., initial, patch)"
    value: ${{ steps.derive.outputs.release_type }}
  apis_json:
    description: "JSON array of API metadata from release-metadata.yaml"
    value: ${{ steps.derive.outputs.apis_json }}
  commonalities_release:
    description: "Commonalities release dependency from release-metadata.yaml"
    value: ${{ steps.derive.outputs.commonalities_release }}
  identity_consent_management_release:
    description: "ICM release dependency from release-metadata.yaml"
    value: ${{ steps.derive.outputs.identity_consent_management_release }}
  source:
    description: "Source of release_tag (release-plan.yaml|release-metadata.yaml|tag)"
    value: ${{ steps.derive.outputs.source }}
  config_error:
    description: "Configuration error message if state derivation failed (empty if successful)"
    value: ${{ steps.derive.outputs.config_error }}
  config_error_type:
    description: "Type of configuration error: missing_file|malformed_yaml|missing_field (empty if successful)"
    value: ${{ steps.derive.outputs.config_error_type }}
  release_issue_number:
    description: "Release Issue number if found (empty if no workflow-owned issue exists)"
    value: ${{ steps.derive.outputs.release_issue_number }}
  release_plan_url:
    description: "URL to release-plan.yaml"
    value: ${{ steps.derive.outputs.release_plan_url }}
  src_commit_sha_short:
    description: "Short SHA of source commit"
    value: ${{ steps.derive.outputs.src_commit_sha_short }}
  meta_release:
    description: "Release metadata summary string"
    value: ${{ steps.derive.outputs.meta_release }}

runs:
  using: composite
  steps:
    - name: Setup Python
      uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5
      with:
        python-version: "3.11"

    - name: Install dependencies
      shell: bash
      run: pip install --quiet pyyaml

    - name: Derive Release State
      id: derive
      shell: python
      env:
        GITHUB_TOKEN: ${{ github.token }}
        GITHUB_SERVER_URL: ${{ github.server_url }}
        RELEASE_TAG_INPUT: ${{ inputs.release_tag }}
        REPO: ${{ github.repository }}
        SCRIPTS_PATH: ${{ github.action_path }}/../../release_automation/scripts
      run: |
        import os
        import sys

        # Add scripts path to module search path
        # SCRIPTS_PATH is like _tooling/release_automation/scripts
        # We need _tooling in sys.path so 'release_automation.scripts' is importable
        scripts_path = os.environ['SCRIPTS_PATH']
        # Go up two levels: scripts -> release_automation -> _tooling
        tooling_root = os.path.dirname(os.path.dirname(scripts_path))
        sys.path.insert(0, tooling_root)
        print(f"Added to sys.path: {tooling_root}")

        from release_automation.scripts.state_manager import ReleaseStateManager
        from release_automation.scripts.github_client import GitHubClient

        # Initialize clients
        repo = os.environ['REPO']
        token = os.environ.get('GITHUB_TOKEN')
        release_tag_input = os.environ.get('RELEASE_TAG_INPUT', '').strip()
        server_url = os.environ.get('GITHUB_SERVER_URL', 'https://github.com')

        gh = GitHubClient(repo=repo, token=token)
        manager = ReleaseStateManager(github_client=gh)

        # Get release info from repository artifacts (authoritative source)
        release_info = manager.get_current_release_info()
        output_file = os.environ['GITHUB_OUTPUT']

        # Handle configuration errors
        if not release_info.success:
            error = release_info.config_error
            with open(output_file, 'a') as f:
                f.write("release_tag=\n")
                f.write("state=\n")
                f.write("source=\n")
                f.write("snapshot_id=\n")
                f.write("snapshot_branch=\n")
                f.write("release_review_branch=\n")
                f.write("src_commit_sha=\n")
                f.write("release_pr_number=\n")
                f.write("release_type=\n")
                f.write("apis_json=\n")
                f.write("commonalities_release=\n")
                f.write("identity_consent_management_release=\n")
                f.write(f"config_error={error.message}\n")
                f.write(f"config_error_type={error.error_type}\n")
                f.write("release_issue_number=\n")
                f.write("release_plan_url=\n")
                f.write("src_commit_sha_short=\n")
                f.write("meta_release=\n")

            # Log error (but don't fail the action - let workflow decide)
            print(f"::warning::Configuration error: {error.message}")
            print(f"Error type: {error.error_type}")
            print(f"File: {error.file_path}")
            if error.field_path:
                print(f"Field: {error.field_path}")
            sys.exit(0)

        # Success case
        release_tag = release_info.release_tag
        state = release_info.state
        snapshot_branch = release_info.snapshot_branch
        source = release_info.source or ''
        release_issue_number = release_info.release_issue_number

        # Get snapshot details if available
        snapshot = None
        if release_tag:
            snapshot = manager.get_current_snapshot(release_tag)

        # Compute derived values
        release_plan_url = f"{server_url}/{repo}/blob/main/release-plan.yaml"

        src_commit_sha_short = ''
        if snapshot and snapshot.src_commit_sha:
            src_commit_sha_short = snapshot.src_commit_sha[:7]
            
        # Read meta_release from release-plan.yaml (raw cycle name, e.g., "Fall26")
        meta_release = ""
        plan = manager._read_release_plan()
        if plan:
            meta_release = plan.get("repository", {}).get("meta_release", "") or ""

        # Write outputs to GITHUB_OUTPUT
        with open(output_file, 'a') as f:
            f.write(f"release_tag={release_tag or ''}\n")
            f.write(f"state={state.value}\n")
            f.write(f"source={source}\n")
            # Clear config_error outputs on success
            f.write("config_error=\n")
            f.write("config_error_type=\n")
            issue_num = release_issue_number if release_issue_number else ''
            f.write(f"release_issue_number={issue_num}\n")
            f.write(f"release_plan_url={release_plan_url}\n")
            f.write(f"src_commit_sha_short={src_commit_sha_short}\n")
            f.write(f"meta_release={meta_release}\n")

            import json
            if snapshot:
                f.write(f"snapshot_id={snapshot.snapshot_id}\n")
                f.write(f"snapshot_branch={snapshot.snapshot_branch}\n")
                f.write(f"release_review_branch={snapshot.release_review_branch}\n")
                f.write(f"src_commit_sha={snapshot.src_commit_sha}\n")
                pr_num = snapshot.release_pr_number if snapshot.release_pr_number else ''
                f.write(f"release_pr_number={pr_num}\n")
                f.write(f"release_type={snapshot.release_type}\n")
                f.write(f"apis_json={json.dumps(snapshot.apis)}\n")
                f.write(f"commonalities_release={snapshot.commonalities_release}\n")
                f.write(f"identity_consent_management_release={snapshot.identity_consent_management_release}\n")
            else:
                # No snapshot â€” use plan data (already read above) for PLANNED state context
                plan_apis = []
                plan_commonalities = ""
                plan_icm = ""
                plan_rtype = release_info.release_type or ""
                if plan:
                    for api in plan.get("apis", []):
                        plan_apis.append({
                            "api_name": api.get("api_name", ""),
                            "api_version": api.get("target_api_version", "")
                        })
                    deps = plan.get("dependencies", {})
                    plan_commonalities = deps.get("commonalities_release", "")
                    plan_icm = deps.get("identity_consent_management_release", "")

                f.write("snapshot_id=\n")
                f.write(f"snapshot_branch={snapshot_branch or ''}\n")
                f.write("release_review_branch=\n")
                f.write("src_commit_sha=\n")
                f.write("release_pr_number=\n")
                f.write(f"release_type={plan_rtype}\n")
                f.write(f"apis_json={json.dumps(plan_apis)}\n")
                f.write(f"commonalities_release={plan_commonalities}\n")
                f.write(f"identity_consent_management_release={plan_icm}\n")

        # Log result for debugging
        print(f"Release tag: {release_tag} (from {source})")
        print(f"State: {state.value}")
        print(f"Release Issue: #{release_issue_number}" if release_issue_number else "Release Issue: None")
        if snapshot:
            print(f"  Snapshot ID: {snapshot.snapshot_id}")
            print(f"  Snapshot branch: {snapshot.snapshot_branch}")
            print(f"  Release PR: {snapshot.release_pr_number or 'None'}")
